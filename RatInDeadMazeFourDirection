/**
 * ðŸ­ RatInDeadMazeFourDirection.java
 * 
 * This program finds all possible paths ðŸ›£ï¸ from the top-left to the bottom-right corner
 * of a maze using recursion ðŸ” and backtracking ðŸ”™. The rat ðŸ­ can move in four directions: 
 * right âž¡ï¸ (R), down â¬‡ï¸ (D), left â¬…ï¸ (L), and up â¬†ï¸ (U). Cells with value 0 are blocked ðŸš«.
 *
 * Author: Adam Warlord
 * GitHub: https://github.com/Warlord27/
 */

public class RatInDeadMazeFourDirection {
    public static void main(String[] args) {
        int row = 4, col = 4;
        int maze[][] = {
            { 1, 0, 1, 1 },
            { 1, 1, 1, 1 },
            { 1, 1, 0, 1 },
            { 1, 0, 0, 1 }
        };
        boolean isVisited[][] = new boolean[row][col];

        System.out.println("ðŸ§­ All possible paths from start to end:");
        print(0, 0, row - 1, col - 1, "", maze, isVisited);
    }

    /**
     * ðŸ” Recursively explores all paths from (sr, sc) to (er, ec).
     *
     * @param sr         current row ðŸ“
     * @param sc         current column ðŸ“
     * @param er         end row ðŸ
     * @param ec         end column ðŸ
     * @param path       current path as a string of directions ðŸ§µ
     * @param maze       the maze grid (1: open âœ…, 0: blocked ðŸš«)
     * @param isVisited  grid to track visited positions ðŸ‘£
     */
    static void print(int sr, int sc, int er, int ec, String path, int[][] maze, boolean[][] isVisited) {
        // ðŸ›‘ Base case: out of bounds or blocked/visited
        if (sr > er || sc > ec || sr < 0 || sc < 0 || maze[sr][sc] == 0 || isVisited[sr][sc]) {
            return;
        }

        // âœ… If destination is reached, print the path
        if (sr == er && sc == ec) {
            System.out.println("âœ… Path found: " + path);
            return;
        }

        // ðŸš© Mark current cell as visited
        isVisited[sr][sc] = true;

        // âž¡ï¸ Explore in all four directions
        print(sr, sc + 1, er, ec, path + "R", maze, isVisited); // Right âž¡ï¸
        print(sr + 1, sc, er, ec, path + "D", maze, isVisited); // Down â¬‡ï¸
        print(sr, sc - 1, er, ec, path + "L", maze, isVisited); // Left â¬…ï¸
        print(sr - 1, sc, er, ec, path + "U", maze, isVisited); // Up â¬†ï¸

        // ðŸ”™ Backtrack: unmark the current cell
        isVisited[sr][sc] = false;
    }
}
