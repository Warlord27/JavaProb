/**
 * ğŸ­ RatInDeadMazeFourDirection.java
 * 
 * This program finds all possible paths ğŸ›£ï¸ from the top-left to the bottom-right corner
 * of a maze using recursion ğŸ” and backtracking ğŸ”™. The rat ğŸ­ can move in four directions: 
 * right â¡ï¸ (R), down â¬‡ï¸ (D), left â¬…ï¸ (L), and up â¬†ï¸ (U). Cells with value 0 are blocked ğŸš«.
 *
 * Author: Adam Warlord
 * GitHub: https://github.com/Warlord27/
 */

public class RatInDeadMazeAnyGrid {
    public static void main(String[] args) {
        // Define the grid (can be any size or shape)
        int[][] maze = {
            { 1, 0, 1, 1, 0 },
            { 1, 1, 1, 1, 1 },
            { 0, 1, 0, 1, 0 },
            { 1, 1, 1, 1, 1 },
            { 1, 0, 1, 0, 1 }
        };

        int row = maze.length; // Number of rows
        int col = maze[0].length; // Number of columns

        // Visited array to track visited cells
        boolean[][] isVisited = new boolean[row][col];

        System.out.println("ğŸ§­ All possible paths from start to end:");
        printPaths(0, 0, row - 1, col - 1, "", maze, isVisited);
    }

    /**
     * ğŸ” Recursively explores all paths from (sr, sc) to (er, ec).
     *
     * @param sr         current row ğŸ“
     * @param sc         current column ğŸ“
     * @param er         end row ğŸ
     * @param ec         end column ğŸ
     * @param path       current path as a string of directions ğŸ§µ
     * @param maze       the maze grid (1: open âœ…, 0: blocked ğŸš«)
     * @param isVisited  grid to track visited positions ğŸ‘£
     */
    static void printPaths(int sr, int sc, int er, int ec, String path, int[][] maze, boolean[][] isVisited) {
        // ğŸ›‘ Base case: out of bounds or blocked/visited
        if (sr < 0 || sc < 0 || sr >= maze.length || sc >= maze[0].length || maze[sr][sc] == 0 || isVisited[sr][sc]) {
            return;
        }

        // âœ… If destination is reached, print the path
        if (sr == er && sc == ec) {
            System.out.println("âœ… Path found: " + path);
            return;
        }

        // ğŸš© Mark current cell as visited
        isVisited[sr][sc] = true;

        // â¡ï¸ Explore in all four directions
        printPaths(sr, sc + 1, er, ec, path + "R", maze, isVisited); // Right â¡ï¸
        printPaths(sr + 1, sc, er, ec, path + "D", maze, isVisited); // Down â¬‡ï¸
        printPaths(sr, sc - 1, er, ec, path + "L", maze, isVisited); // Left â¬…ï¸
        printPaths(sr - 1, sc, er, ec, path + "U", maze, isVisited); // Up â¬†ï¸

        // ğŸ”™ Backtrack: unmark the current cell
        isVisited[sr][sc] = false;
    }
}
